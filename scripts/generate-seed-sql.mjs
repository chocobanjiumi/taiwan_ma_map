#!/usr/bin/env node
/**
 * Generate SQL seed file from collected clinic data
 *
 * Reads from:
 *   - scripts/data/google-places-raw.json (Google Places API output)
 *   - scripts/data/curated-clinics.json (manually curated fallback data)
 *
 * Outputs:
 *   - supabase/migrations/00005_seed_real_clinics.sql
 *
 * Usage:
 *   node scripts/generate-seed-sql.mjs [--source google|curated|merge]
 */

import { readFileSync, writeFileSync, existsSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';

const __dirname = dirname(fileURLToPath(import.meta.url));
const DATA_DIR = join(__dirname, 'data');
const OUTPUT = join(__dirname, '..', 'supabase', 'migrations', '00005_seed_real_clinics.sql');

const source = process.argv[2]?.replace('--source=', '') || 'curated';

function loadJSON(filepath) {
  if (!existsSync(filepath)) return [];
  try {
    return JSON.parse(readFileSync(filepath, 'utf-8'));
  } catch {
    return [];
  }
}

function toSlug(name) {
  // Create URL-friendly slug from Chinese clinic name
  // Use pinyin-like transliteration for common characters, fallback to index
  return name
    .replace(/診所$/, '')
    .replace(/[（）()「」【】]/g, '')
    .replace(/\s+/g, '-')
    .replace(/[^\w\u4e00-\u9fff-]/g, '')
    .toLowerCase()
    .trim() || 'clinic';
}

function generateUniqueSlug(name, existingSlugs) {
  let base = toSlug(name);
  // For Chinese names, create a romanized slug
  const romanMap = {
    '星采': 'starclinic', '星和': 'starnic', '晶華': 'jinhua',
    '美麗晶華': 'beauty-jinhua', '悅美': 'yuemei', '悠美': 'youmei',
    '米蘭': 'milan', '雅偲': 'artskin', '膚適美': 'fusimei',
    '光澤': 'guangze', '淨妍': 'jingyan', '元和雅': 'yuanheya',
    '渾然天成': 'hunran', '麗晶': 'lijing', '極光': 'aurora',
    '上立': 'shangli', '法喬': 'faqiao', '願麗': 'yuanli',
    '愛爾麗': 'aily', '佳醫': 'jiaye', '首爾': 'seoul',
    '采醫': 'caiyi', '彭賢禮': 'pengxianli', '盧靜怡': 'lujingyi',
    '長虹': 'changhong', '維格': 'weige', '美加': 'meijia',
    '童顏': 'tongyan', '京硯': 'jingyan2', '粹究': 'cuijiu',
    '聖仁': 'shengren', '瑞安': 'ruian', '潘朵拉': 'pandora',
    '澤林': 'zelin', '群英': 'qunying', '高雄': 'kaohsiung',
  };

  // Try to find a romanized match
  for (const [cn, en] of Object.entries(romanMap)) {
    if (name.includes(cn)) {
      base = en;
      break;
    }
  }

  // If still Chinese, create a numeric slug
  if (/[\u4e00-\u9fff]/.test(base)) {
    base = 'clinic';
  }

  let slug = base;
  let counter = 1;
  while (existingSlugs.has(slug)) {
    slug = `${base}-${counter}`;
    counter++;
  }
  existingSlugs.add(slug);
  return slug;
}

function escapeSQL(str) {
  if (str == null) return 'NULL';
  return `'${str.replace(/'/g, "''")}'`;
}

function generateSQL(clinics) {
  const existingSlugs = new Set([
    // Slugs from existing seed data (00004)
    'yuemei-clinic', 'starclinic', 'crystal-beauty',
    'milan-clinic', 'beautiful-crystal', 'artskin-clinic',
  ]);

  // Existing clinic names to skip
  const existingNames = new Set([
    '悅美整形外科診所', '星采整形外科診所', '晶華美醫診所',
    '米蘭時尚診所', '美麗晶華診所', '雅偲皮膚科診所',
  ]);

  // Filter out existing clinics and validate
  const newClinics = clinics.filter(c => {
    if (existingNames.has(c.name)) return false;
    if (!c.lat || !c.lng) return false;
    if (!c.name || !c.address) return false;
    return true;
  });

  // Deduplicate by name
  const seen = new Set();
  const unique = newClinics.filter(c => {
    if (seen.has(c.name)) return false;
    seen.add(c.name);
    return true;
  });

  console.log(`Processing ${unique.length} clinics (${clinics.length} total, ${clinics.length - unique.length} filtered)`);

  let sql = `-- Real clinic data for Taipei & New Taipei
-- Generated by scripts/generate-seed-sql.mjs
-- Source: ${source}
-- Count: ${unique.length} clinics

-- Clear existing seed data (keep categories)
DELETE FROM public.treatments;
DELETE FROM public.clinics;

-- Insert clinics
`;

  // First pass: assign slugs to all clinics
  const clinicSlugs = new Map();
  for (const clinic of unique) {
    const slug = generateUniqueSlug(clinic.name, existingSlugs);
    clinicSlugs.set(clinic.name, slug);
  }

  for (const clinic of unique) {
    const slug = clinicSlugs.get(clinic.name);
    const rating = Math.min(5.0, Math.max(0, Number(clinic.rating) || 0)).toFixed(1);
    const reviewCount = Math.max(0, parseInt(clinic.reviewCount) || 0);
    const city = clinic.city || '台北市';
    const district = clinic.district || '';
    const phone = clinic.phone || null;
    const website = clinic.website || null;

    sql += `INSERT INTO public.clinics (name, slug, address, district, city, phone, website, rating, review_count, location) VALUES
  (${escapeSQL(clinic.name)}, ${escapeSQL(slug)}, ${escapeSQL(clinic.address)}, ${escapeSQL(district)}, ${escapeSQL(city)},
   ${escapeSQL(phone)}, ${escapeSQL(website)}, ${rating}, ${reviewCount},
   extensions.ST_SetSRID(extensions.ST_MakePoint(${clinic.lng}, ${clinic.lat}), 4326)::extensions.geography);\n\n`;
  }

  // Generate representative treatments for each clinic
  sql += `\n-- Generate representative treatments for each clinic\n`;
  sql += `-- Assign 2-4 random treatment categories to each clinic with realistic pricing\n`;
  sql += generateTreatmentsSQL(unique, clinicSlugs);

  return sql;
}

function generateTreatmentsSQL(clinics, clinicSlugs) {
  // Treatment templates with realistic pricing
  const treatmentTemplates = [
    { category: 'pico-laser', name: '皮秒雷射', priceMin: 5000, priceMax: 15000, unit: '次' },
    { category: 'pico-laser', name: '皮秒雷射除斑', priceMin: 6000, priceMax: 12000, unit: '次' },
    { category: 'hyaluronic-acid', name: '玻尿酸填充', priceMin: 8000, priceMax: 25000, unit: 'cc' },
    { category: 'hyaluronic-acid', name: '玻尿酸豐唇', priceMin: 8000, priceMax: 15000, unit: 'cc' },
    { category: 'botox', name: '肉毒瘦小臉', priceMin: 4000, priceMax: 10000, unit: '次' },
    { category: 'botox', name: '肉毒除皺', priceMin: 3000, priceMax: 8000, unit: '次' },
    { category: 'thermage', name: '電波拉皮', priceMin: 35000, priceMax: 80000, unit: '次' },
    { category: 'thermage', name: '鳳凰電波全臉', priceMin: 50000, priceMax: 90000, unit: '次' },
    { category: 'ultherapy', name: '音波拉提', priceMin: 30000, priceMax: 80000, unit: '次' },
    { category: 'ultherapy', name: '第三代音波拉提', priceMin: 40000, priceMax: 100000, unit: '次' },
    { category: 'rhinoplasty', name: '結構式隆鼻', priceMin: 50000, priceMax: 150000, unit: '次' },
    { category: 'double-eyelid', name: '縫雙眼皮', priceMin: 15000, priceMax: 30000, unit: '次' },
    { category: 'double-eyelid', name: '割雙眼皮', priceMin: 25000, priceMax: 50000, unit: '次' },
    { category: 'liposuction', name: '威塑抽脂', priceMin: 60000, priceMax: 180000, unit: '區域' },
    { category: 'laser-whitening', name: '雷射美白', priceMin: 3000, priceMax: 8000, unit: '次' },
    { category: 'gentle-laser', name: '淨膚雷射', priceMin: 2000, priceMax: 5000, unit: '次' },
  ];

  let sql = '\n';

  // Deterministic "random" assignment based on clinic index
  for (let i = 0; i < clinics.length; i++) {
    const clinic = clinics[i];
    // Each clinic gets 2-4 treatments
    const numTreatments = 2 + (i % 3);
    const startIdx = (i * 3) % treatmentTemplates.length;

    const selectedTreatments = [];
    const usedCategories = new Set();
    for (let j = 0; j < numTreatments; j++) {
      const tmpl = treatmentTemplates[(startIdx + j * 2) % treatmentTemplates.length];
      if (usedCategories.has(tmpl.category)) continue;
      usedCategories.add(tmpl.category);
      selectedTreatments.push(tmpl);
    }

    for (const tmpl of selectedTreatments) {
      // Add slight price variation per clinic (±15%)
      const variance = 0.85 + (((i * 7 + selectedTreatments.indexOf(tmpl) * 13) % 30) / 100);
      const pMin = Math.round(tmpl.priceMin * variance / 1000) * 1000;
      const pMax = Math.round(tmpl.priceMax * variance / 1000) * 1000;
      const isPopular = selectedTreatments.indexOf(tmpl) === 0;

      const clinicSlug = clinicSlugs.get(clinic.name);
      sql += `INSERT INTO public.treatments (clinic_id, category_id, name, price_min, price_max, price_unit, is_popular)
SELECT c.id, tc.id, ${escapeSQL(tmpl.name)}, ${pMin}, ${pMax}, ${escapeSQL(tmpl.unit)}, ${isPopular}
FROM public.clinics c, public.treatment_categories tc
WHERE c.slug = ${escapeSQL(clinicSlug)} AND tc.slug = ${escapeSQL(tmpl.category)};\n\n`;
    }
  }

  return sql;
}

function main() {
  console.log(`=== SQL Seed Generator (source: ${source}) ===\n`);

  let clinics = [];

  if (source === 'google' || source === 'merge') {
    const googleData = loadJSON(join(DATA_DIR, 'google-places-raw.json'));
    console.log(`Google Places data: ${googleData.length} records`);
    clinics.push(...googleData);
  }

  if (source === 'curated' || source === 'merge') {
    const curatedData = loadJSON(join(DATA_DIR, 'curated-clinics.json'));
    console.log(`Curated data: ${curatedData.length} records`);
    clinics.push(...curatedData);
  }

  if (clinics.length === 0) {
    console.error('No data found. Run fetch scripts first or check data files.');
    process.exit(1);
  }

  const sql = generateSQL(clinics);
  writeFileSync(OUTPUT, sql, 'utf-8');
  console.log(`\nGenerated: ${OUTPUT}`);
}

main();
